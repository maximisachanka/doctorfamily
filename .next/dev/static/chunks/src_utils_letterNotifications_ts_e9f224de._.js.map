{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Study/commercial-projects/smartmedical/src/utils/letterNotifications.ts"],"sourcesContent":["// Утилиты для управления уведомлениями о письмах в localStorage\n\nconst NOTIFIED_LETTERS_KEY = 'letter-notifications-notified';\n\n/**\n * Очистить уведомление о письме (когда пользователь открыл и прочитал письмо)\n */\nexport function clearLetterNotification(letterId: number): void {\n  if (typeof window === 'undefined') return;\n\n  try {\n    const notifiedLetters = JSON.parse(\n      localStorage.getItem(NOTIFIED_LETTERS_KEY) || '[]'\n    ) as number[];\n\n    // Удаляем ID письма и ID+10000 (для thread messages)\n    const updated = notifiedLetters.filter(\n      (id) => id !== letterId && id !== letterId + 10000\n    );\n\n    localStorage.setItem(NOTIFIED_LETTERS_KEY, JSON.stringify(updated));\n  } catch (error) {\n  }\n}\n\n/**\n * Проверить, было ли уже показано уведомление для письма\n */\nexport function wasLetterNotified(letterId: number, isThreadMessage = false): boolean {\n  if (typeof window === 'undefined') return false;\n\n  try {\n    const notifiedLetters = JSON.parse(\n      localStorage.getItem(NOTIFIED_LETTERS_KEY) || '[]'\n    ) as number[];\n\n    const checkId = isThreadMessage ? letterId + 10000 : letterId;\n    return notifiedLetters.includes(checkId);\n  } catch (error) {\n    return false;\n  }\n}\n"],"names":[],"mappings":"AAAA,gEAAgE;;;;;;;AAEhE,MAAM,uBAAuB;AAKtB,SAAS,wBAAwB,QAAgB;IACtD;;IAEA,IAAI;QACF,MAAM,kBAAkB,KAAK,KAAK,CAChC,aAAa,OAAO,CAAC,yBAAyB;QAGhD,qDAAqD;QACrD,MAAM,UAAU,gBAAgB,MAAM,CACpC,CAAC,KAAO,OAAO,YAAY,OAAO,WAAW;QAG/C,aAAa,OAAO,CAAC,sBAAsB,KAAK,SAAS,CAAC;IAC5D,EAAE,OAAO,OAAO,CAChB;AACF;AAKO,SAAS,kBAAkB,QAAgB,EAAE,kBAAkB,KAAK;IACzE;;IAEA,IAAI;QACF,MAAM,kBAAkB,KAAK,KAAK,CAChC,aAAa,OAAO,CAAC,yBAAyB;QAGhD,MAAM,UAAU,kBAAkB,WAAW,QAAQ;QACrD,OAAO,gBAAgB,QAAQ,CAAC;IAClC,EAAE,OAAO,OAAO;QACd,OAAO;IACT;AACF","debugId":null}}]
}