{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 52, "column": 0}, "map": {"version":3,"sources":["file:///C:/Study/commercial-projects/smartmedical/src/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from '@prisma/client';\r\n\r\nconst globalForPrisma = globalThis as unknown as {\r\n  prisma: PrismaClient | undefined;\r\n};\r\n\r\nexport const prisma =\r\n  globalForPrisma.prisma ??\r\n  new PrismaClient({\r\n    log: process.env.NODE_ENV === 'development' ? ['query', 'error', 'warn'] : ['error'],\r\n  });\r\n\r\nif (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;\r\n\r\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf,KAAK,uCAAyC;QAAC;QAAS;QAAS;KAAO,GAAG;AAC7E;AAEF,wCAA2C,gBAAgB,MAAM,GAAG","debugId":null}},
    {"offset": {"line": 71, "column": 0}, "map": {"version":3,"sources":["file:///C:/Study/commercial-projects/smartmedical/src/app/api/auth/check-unique/route.ts"],"sourcesContent":["import { NextRequest, NextResponse } from \"next/server\";\r\nimport { prisma } from \"@/lib/prisma\";\r\n\r\n/**\r\n * Check if login or phone is already taken\r\n * GET /api/auth/check-unique?login=xxx or ?phone=xxx\r\n */\r\nexport async function GET(request: NextRequest) {\r\n  try {\r\n    const searchParams = request.nextUrl.searchParams;\r\n    const login = searchParams.get('login');\r\n    const phone = searchParams.get('phone');\r\n    const email = searchParams.get('email');\r\n    const excludeId = searchParams.get('excludeId'); // For profile updates\r\n\r\n    if (!login && !phone && !email) {\r\n      return NextResponse.json(\r\n        { error: \"Укажите login, phone или email для проверки\" },\r\n        { status: 400 }\r\n      );\r\n    }\r\n\r\n    const excludeCondition = excludeId\r\n      ? { id: { not: parseInt(excludeId) } }\r\n      : {};\r\n\r\n    // Check login uniqueness\r\n    if (login) {\r\n      const existingLogin = await prisma.patient.findFirst({\r\n        where: {\r\n          login: login,\r\n          ...excludeCondition,\r\n        },\r\n      });\r\n\r\n      return NextResponse.json({\r\n        field: 'login',\r\n        value: login,\r\n        isUnique: !existingLogin,\r\n        message: existingLogin ? 'Этот логин уже занят' : null,\r\n      });\r\n    }\r\n\r\n    // Check phone uniqueness\r\n    if (phone) {\r\n      // Normalize phone - keep only digits\r\n      const normalizedPhone = phone.replace(/\\D/g, '');\r\n      const last9Digits = normalizedPhone.slice(-9);\r\n\r\n      // Получаем все телефоны и проверяем после нормализации\r\n      // (для совместимости со старыми данными в разных форматах)\r\n      const allPatients = await prisma.patient.findMany({\r\n        where: excludeCondition,\r\n        select: { id: true, phone: true },\r\n      });\r\n\r\n      const existingPhone = allPatients.find(patient => {\r\n        const patientNormalized = patient.phone.replace(/\\D/g, '');\r\n        // Проверяем полное совпадение или совпадение последних 9 цифр\r\n        return patientNormalized === normalizedPhone ||\r\n               patientNormalized.slice(-9) === last9Digits;\r\n      });\r\n\r\n      return NextResponse.json({\r\n        field: 'phone',\r\n        value: phone,\r\n        isUnique: !existingPhone,\r\n        message: existingPhone ? 'Этот номер телефона уже зарегистрирован' : null,\r\n      });\r\n    }\r\n\r\n    // Check email uniqueness\r\n    if (email) {\r\n      const existingEmail = await prisma.patient.findFirst({\r\n        where: {\r\n          email: email.toLowerCase(),\r\n          ...excludeCondition,\r\n        },\r\n      });\r\n\r\n      return NextResponse.json({\r\n        field: 'email',\r\n        value: email,\r\n        isUnique: !existingEmail,\r\n        message: existingEmail ? 'Этот email уже зарегистрирован' : null,\r\n      });\r\n    }\r\n\r\n    return NextResponse.json({ error: \"Неизвестная ошибка\" }, { status: 400 });\r\n  } catch (error) {\r\n    console.error(\"Check unique error:\", error);\r\n    return NextResponse.json(\r\n      { error: \"Ошибка при проверке уникальности\" },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAMO,eAAe,IAAI,OAAoB;IAC5C,IAAI;QACF,MAAM,eAAe,QAAQ,OAAO,CAAC,YAAY;QACjD,MAAM,QAAQ,aAAa,GAAG,CAAC;QAC/B,MAAM,QAAQ,aAAa,GAAG,CAAC;QAC/B,MAAM,QAAQ,aAAa,GAAG,CAAC;QAC/B,MAAM,YAAY,aAAa,GAAG,CAAC,cAAc,sBAAsB;QAEvE,IAAI,CAAC,SAAS,CAAC,SAAS,CAAC,OAAO;YAC9B,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAA8C,GACvD;gBAAE,QAAQ;YAAI;QAElB;QAEA,MAAM,mBAAmB,YACrB;YAAE,IAAI;gBAAE,KAAK,SAAS;YAAW;QAAE,IACnC,CAAC;QAEL,yBAAyB;QACzB,IAAI,OAAO;YACT,MAAM,gBAAgB,MAAM,gIAAM,CAAC,OAAO,CAAC,SAAS,CAAC;gBACnD,OAAO;oBACL,OAAO;oBACP,GAAG,gBAAgB;gBACrB;YACF;YAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB,OAAO;gBACP,OAAO;gBACP,UAAU,CAAC;gBACX,SAAS,gBAAgB,yBAAyB;YACpD;QACF;QAEA,yBAAyB;QACzB,IAAI,OAAO;YACT,qCAAqC;YACrC,MAAM,kBAAkB,MAAM,OAAO,CAAC,OAAO;YAC7C,MAAM,cAAc,gBAAgB,KAAK,CAAC,CAAC;YAE3C,uDAAuD;YACvD,2DAA2D;YAC3D,MAAM,cAAc,MAAM,gIAAM,CAAC,OAAO,CAAC,QAAQ,CAAC;gBAChD,OAAO;gBACP,QAAQ;oBAAE,IAAI;oBAAM,OAAO;gBAAK;YAClC;YAEA,MAAM,gBAAgB,YAAY,IAAI,CAAC,CAAA;gBACrC,MAAM,oBAAoB,QAAQ,KAAK,CAAC,OAAO,CAAC,OAAO;gBACvD,8DAA8D;gBAC9D,OAAO,sBAAsB,mBACtB,kBAAkB,KAAK,CAAC,CAAC,OAAO;YACzC;YAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB,OAAO;gBACP,OAAO;gBACP,UAAU,CAAC;gBACX,SAAS,gBAAgB,4CAA4C;YACvE;QACF;QAEA,yBAAyB;QACzB,IAAI,OAAO;YACT,MAAM,gBAAgB,MAAM,gIAAM,CAAC,OAAO,CAAC,SAAS,CAAC;gBACnD,OAAO;oBACL,OAAO,MAAM,WAAW;oBACxB,GAAG,gBAAgB;gBACrB;YACF;YAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;gBACvB,OAAO;gBACP,OAAO;gBACP,UAAU,CAAC;gBACX,SAAS,gBAAgB,mCAAmC;YAC9D;QACF;QAEA,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,OAAO;QAAqB,GAAG;YAAE,QAAQ;QAAI;IAC1E,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,uBAAuB;QACrC,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAmC,GAC5C;YAAE,QAAQ;QAAI;IAElB;AACF","debugId":null}}]
}